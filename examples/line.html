<!DOCTYPE html>
<head>
  <title>Line Example</title>
  <script src="../dist/threebox.js" type="text/javascript"></script>
  <link href="./css/threebox.css" rel="stylesheet" />
  <script src="config.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v1.11.1/mapbox-gl.js"></script>
  <link
    href="https://api.mapbox.com/mapbox-gl-js/v1.11.1/mapbox-gl.css"
    rel="stylesheet"
  />
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
      margin: 0;
      background: black;
    }

    #map {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="map" class="map"></div>

  <script>
    // this demo generates lineGeometry for 50 lines, and adds them as lines to the map with random widths, and colors based on latitudes of their unique endpoints

    if (!config)
      console.error(
        "Config not set! Make a copy of 'config_template.js', add in your access token, and save the file as 'config.js'."
      );

    mapboxgl.accessToken = config.accessToken;

    var map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/dark-v9",
      zoom: 2,
      pitch: 45,
    });

    // randomly generate some line arcs (not essential for understanding this demo)

    var lines = new Array();
    var arcSegments = 25;
    var lineQuantity = 50;

    for (var i = 0; i < lineQuantity; i++) {
      var line = new Array();
      var destination = [
        300 * (Math.random() - 0.5),
        140 * (Math.random() - 0.5),
      ];
      var maxElevation =
        Math.pow(Math.abs(destination[0] * destination[1]), 0.5) * 80000;

      var increment = destination.map(function (direction) {
        return direction / arcSegments;
      });

      for (var l = 0; l <= arcSegments; l++) {
        var waypoint = increment.map(function (direction) {
          return direction * l;
        });

        var waypointElevation =
          Math.sin((Math.PI * l) / arcSegments) * maxElevation;

        waypoint.push(waypointElevation);
        line.push(waypoint);
      }

      lines.push(line);
    }

    console.log("lineGeometries of the lines: ", lines);

    // instantiate threebox

    map.on("style.load", function () {
      map.addLayer({
        id: "custom_layer",
        type: "custom",
        onAdd: function (map, mbxContext) {
          tb = new Threebox(map, mbxContext, { defaultLights: true });

          let texture = new THREE.TextureLoader().load("./road1.png");
          texture.anisotropy = 16;
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          let camera = tb.camera;
          let material = new MeshLineMaterial({
            map: texture,
            useMap: true,
            lineWidth: 13,
            sizeAttenuation: false,
            transparent: true,
            near: camera.near,
            far: camera.far,
		  });

		//   coordinateToVector3(coordinate, z = 0) {
		// 	const map = this.getMap();
		// 	if (!map) {
		// 		return null;
		// 	}
		// 	if (!(coordinate instanceof maptalks.Coordinate)) {
		// 		coordinate = new maptalks.Coordinate(coordinate);
		// 	}
		// 	const p = map.coordinateToPoint(coordinate, getTargetZoom(map));
		// 	return new THREE.Vector3(p.x, p.y, z);
		// }
		  
		//   function getLinePosition(lineString, layer, cenerter) {
		// 		const positions = [];
		// 		const positionsV = [];
		// 		if (Array.isArray(lineString) && lineString[0] instanceof THREE.Vector3) {
		// 			for (let i = 0, len = lineString.length; i < len; i++) {
		// 				const v = lineString[i];
		// 				positions.push(v.x, v.y, v.z);
		// 				positionsV.push(v);
		// 			}
		// 		} else {
		// 			if (Array.isArray(lineString)) lineString = new maptalks.LineString(lineString);
		// 			if (!lineString || !(lineString instanceof maptalks.LineString)) return;
		// 			const z = 0;
		// 			const coordinates = lineString.getCoordinates();
		// 			const centerPt = layer.coordinateToVector3(cenerter || lineString.getCenter());
		// 			for (let i = 0, len = coordinates.length; i < len; i++) {
		// 				let coordinate = coordinates[i];
		// 				if (Array.isArray(coordinate)) {
		// 					coordinate = new maptalks.Coordinate(coordinate);
		// 				}
		// 				const v = layer.coordinateToVector3(coordinate, z).sub(centerPt);
		// 				positions.push(v.x, v.y, v.z);
		// 				positionsV.push(v);
		// 			}
		// 		}
		// 		return {
		// 			positions: positions,
		// 			positionsV: positionsV
		// 		}
		// 	}

		//   const geometry = new THREE.Geometry();
        //         for (let i = 0; i < positions.length; i += 3) {
        //             geometry.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
        //   }
        //   const meshLine = new MeshLine();
        //   meshLine.setGeometry(geometry);
        //   const lineMesh = new THREE.Mesh(meshLine.geometry, material);
        //   tb.add(lineMesh);

          for (line of lines) {
            // var lineOptions = {
            // 	geometry: line,
            // 	color: (line[1][1]/180) * 0xffffff, // color based on latitude of endpoint
            // 	width: Math.random() + 1 // random width between 1 and 2
            // }
			//  let simplelineMesh = tb.line(lineOptions);


			   const geometry = new THREE.Geometry();
                for (let i = 0; i < line.length; i += 3) {
                    geometry.vertices.push(new THREE.Vector3(line[i][0], line[i][1], 0));
               }
			 const meshLine = new MeshLine();
				meshLine.setGeometry(geometry);
				const lineMesh = new THREE.Mesh(meshLine.geometry, material);
				tb.add(lineMesh);
          }
        },

        render: function (gl, matrix) {
          tb.update();
        },
      });
    });
  </script>
</body>
