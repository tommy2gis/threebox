<!DOCTYPE html>
<html>
  <head>
    <title>示例</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>

    <script src="../dist/mapbox-gl-dev.js"></script>
    <link href="../dist/mapbox-gl.css" rel="stylesheet" />
    <script src="../dist/MAP_STYLE.darkblue.js"></script>
    <script src="../dist/threebox.js"></script>
    <script src="material.js"></script>
    <script>
      var map = (window.map = new mapboxgl.Map({
        container: "map",
        zoom: 10,
        center: [120.57022, 32.3858585],
        style: style,
        hash: true,
      }));

      var origin = [120.57022, 32.3858585, 0];

      map.on("style.load", function () {
        map.addLayer(
          {
            id: "custom_layer",
            type: "custom",
            onAdd: function (map, mbxContext) {
              onAdd(map, mbxContext);
            },

            render: function (gl, matrix) {
              tb.update();
            },
          },
          "兴趣点-level-towm"
        ); //添加到建筑物图层之后
      });

      function onAdd(map, mbxContext) {
        window.tb = new Threebox(map, mbxContext, {
          defaultLights: true,
          enableSelectingObjects: true,
        }); //初始化

        var options = {
          type: "dae",
          obj: "models/building.DAE",
          material: new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("images/building_top.png"),
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 1,
            wireframe: false,
          }),
          scale: 1,
          anchor: "center",
          units: "meters",
          rotation: { x: 90, y: 180, z: 0 },
        };

        var options2 = {
          type: "dae",
          obj: "models/f5.DAE",
          material: new THREE.MeshPhongMaterial({
            color: 0x63a3,
            map: new THREE.TextureLoader().load("images/building2.png"),
            specular: 0x20202,
            shininess: 20,
          }),
          scale: 1,
          units: "meters",
          anchor: "center",
          rotation: { x: 90, y: 180, z: 0 },
        };

        var floor;

        tb.loadObj(options2, function (model) {
          floor = model.setCoords([120.5664, 32.3854]);
        });

        tb.loadObj(options, function (model) {
          const truck = model.setCoords([120.56642, 32.38535]);
          truck.addEventListener("SelectedChange", onSelectedChange, false);
          tb.add(truck);
        });

        function onSelectedChange(e) {
          let selected = e.detail.selected;
          if (selected) {
            if (floor) {
              tb.add(floor);
            }
            e.detail.children.forEach((ele) => {
              ele.children[0].material.opacity = 0.1;
            });
          } else {
            if (floor) {
              tb.remove(floor, false);
            }
            e.detail.children.forEach((ele) => {
              ele.children[0].material.opacity = 1;
            });
          }
        }

        function addRing() {
          var ringmaterial = getRingMaterial(0);
          const ringgeometry = new THREE.RingBufferGeometry(
            0.001,
            10,
            20,
            5,
            0,
            Math.PI * 2
          );
          const ringmesh = new THREE.Mesh(ringgeometry, ringmaterial);

          tb.add(
            tb
              .Object3D({ obj: ringmesh, adjustment: { x: 0, y: 0, z: 0.5 } })
              .setCoords([ 120.55881500244139,
          32.389655856727444])
          );

          return ringmesh;
        }

        function addBar(material) {
          const cubeGeo = new THREE.BoxBufferGeometry(0.05, 40, 0.05);
          cubeGeo.setAttribute(
            "color",
            new THREE.BufferAttribute(new Float32Array(24 * 3), 3)
          ); // setAttribute 以前是.addAttribute
          // 相当于在 shader中创建了 attribute vec4 position
          const colors1 = cubeGeo.attributes.color;
          for (let i = 0; i < 24; i += 2) {
            let r = Math.random() * 0.8,
              g = Math.random() * 0.7,
              b = Math.random() * 0.5;
            colors1.setXYZ(i, r, g, b);
            colors1.setXYZ(i + 1, r, g, b);
          }
          const k = 2;
          colors1.setXYZ(k * 4 + 0, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 1, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 2, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 3, 0.0, 1.0, 1.0);
          const cube = new THREE.Mesh(cubeGeo, material);

          cube.rotation.x = Math.PI / 2;
          tb.add(
            tb
              .Object3D({ obj: cube, adjustment: { x: 0, y: 0, z: 0.5 } })
              .setCoords([ 120.55881500244139,
          32.389655856727444])
          );
        }

        function addSphere() {
          let spheregeo = new THREE.SphereGeometry( 10, 40, 40,0,Math.PI*2,0,Math.PI/2);
          const mesh = new THREE.Mesh(spheregeo, getSphereMaterial());
              mesh.rotation.x = Math.PI / 2;
              tb.add( tb
                .Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 0.001 } })
                .setCoords([ 120.55812835693358,
          32.39520021904035]));
        }

        function getWallGeometry(points,height) {
                let positions = []
                let uvs = []
                for (let i = 0, j = positions.length, t = uvs.length; i < points.length - 1; i++) {
                let vUvyMax = 1
                let left = points[i]
                let right = points[i + 1]
                positions[j++] = left.x
                positions[j++] = left.y
                positions[j++] = 0
                uvs[t++] = 0
                uvs[t++] = 0

                positions[j++] = right.x
                positions[j++] = right.y
                positions[j++] = 0
                uvs[t++] = 1
                uvs[t++] = 0

                positions[j++] = left.x
                positions[j++] = left.y
                positions[j++] = height
                uvs[t++] = 0
                uvs[t++] = vUvyMax

                positions[j++] = left.x
                positions[j++] = left.y
                positions[j++] = height
                uvs[t++] = 0
                uvs[t++] = vUvyMax

                positions[j++] = right.x
                positions[j++] = right.y
                positions[j++] = 0
                uvs[t++] = 1
                uvs[t++] = 0

                positions[j++] = right.x
                positions[j++] = right.y
                positions[j++] = height
                uvs[t++] = 1
                uvs[t++] = vUvyMax
                }
                let geometry = new THREE.BufferGeometry()
                geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3))
                geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2))
                return geometry;
            }
        function addWall(params) {
          
          const geometry = getWallGeometry([
                {x:-1.0,y: -1.0},
                {x:1.0, y:-1.0},
                {x:1.0, y: 1.0},
                { x:1.0, y: 1.0},
                { x:-1.0, y: 1.0},
                {x:-1.0, y:-1.0}
            ],0.5);
            const mesh = new THREE.Mesh( geometry, getWallMaterial() );

                tb.add(tb.Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 0.01 }})
                .setCoords([  120.56224822998045,
          32.39326154281592]))
          return mesh;

        }

        function addCone(params) {
          let geometry = new THREE.CylinderBufferGeometry(
                  0,
                  6.4,
                  11,
                  4,
                  1,
                  false,
                  0,
                  6.3
                );
                geometry.scale(0.05,0.05,0.05);
               // geometry.computeBoundingSphere();
                const mesh = new THREE.Mesh(geometry, getConeMaterial());
              mesh.rotation.x = -Math.PI / 2;
              tb.add(tb
                .Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 5 } })
                .setCoords([120.56310653686523,32.392772337566306]));

                return mesh
        }

        var ringmesh = addRing();
        var wallmesh = addWall();
        var conemesh=addCone();
        var shaderBarmaterial=getShaderBarMaterial()
        addBar(shaderBarmaterial);
        var ShaderBar=shaderBarmaterial.ShaderBar;
        addSphere();
       


        var animate = function () {
          ringmesh.material.uniforms.time.value += 0.002;
          wallmesh.material.uniforms.time.value += 0.002;
          conemesh.material.uniforms.time.value += 0.05;
          conemesh.rotation.y+=0.02;
          ShaderBar.uniforms.boxH.value =  ShaderBar.uniforms.boxH.value + 0.5
                if( ShaderBar.uniforms.boxH.value > 40){
                    ShaderBar.uniforms.boxH.value =  -10.0
                }

          requestAnimationFrame(animate);
          map.triggerRepaint();
          //threebox.update();
        };

        animate();
      }
    </script>
  </body>
</html>
