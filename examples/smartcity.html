<!DOCTYPE html>
<html>
  <head>
    <title>示例</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <style>
      html,
      body,
      #map {
        margin: 0;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
    <div style="display: none" class="boxContainer">
    <script src="../dist/mapbox-gl-dev.js"></script>
    <link href="../dist/mapbox-gl.css" rel="stylesheet" />
    <script src="https://cdn.bootcdn.net/ajax/libs/Turf.js/5.1.6/turf.min.js"></script>
    <script src="http://learningthreejs.com/data/tweenjs_for_smooth_animation/vendor/three.js/examples/js/Tween.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/deck.gl@8.3.7/dist/dist.dev.js"></script>
    <script src="../dist/MAP_STYLE.darkblue.js"></script>
    <script src="../dist/threebox.js"></script>
    <script src="material.js"></script>
    <script src="./geojson/tripdata.js"></script>
    <script>
      var map = (window.map = new mapboxgl.Map({
        container: "map",
        zoom: 10,
        center: [120.57022, 32.3858585],
        style: style,
        hash: true,
      }));
      const el = document.getElementById("map");
      let resolution = new THREE.Vector2(el.offsetWidth, el.offsetHeight);
      var origin = [120.57022, 32.3858585, 0];
      const { MapboxLayer, TripsLayer } = deck;
      map.on("style.load", function () {
        map.addLayer(
          {
            id: "custom_layer",
            type: "custom",
            onAdd: function (map, mbxContext) {
              onAdd(map, mbxContext);
            },

            render: function (gl, matrix) {
              tb.update();
              TWEEN.update();
            },
          },
          "建筑物"
        ); //添加到建筑物图层之后
      });

      function onAdd(map, mbxContext) {
        window.tb = new Threebox(map, mbxContext, {
          defaultLights: true,
          enableSelectingObjects: true,
          enableTooltips: false,
          
        }); //初始化

        var options = {
          type: "dae",
          obj: "models/building.DAE",
          material:[ new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("images/building2.png"),
            side: THREE.DoubleSide,
            transparent: true,
            wireframe: false,
            opacity: 1,
          })],
          scale: 1,
          anchor: "center",
          units: "meters",
          rotation: { x: 90, y: 180, z: 0 },
        };

        function getFloorOption(floor) {
          return {
            type: "dae",
            obj: "models/" + floor + ".DAE",
            material: new THREE.MeshPhongMaterial({
              color: 0x63a3,
              map: new THREE.TextureLoader().load("images/building2.png"),
              specular: 0x20202,
              //wireframe:true,
              shininess: 20,
            }),
            scale: 1,
            units: "meters",
            anchor: "center",
            rotation: { x: 90, y: 207.1, z: 0 },
          };
        }

        // var floors = [];
        // ["floor1", "floor2", "floor3", "floor4", "floor5"].forEach(
        //   (fl, index) => {
        //     tb.loadObj(getFloorOption(fl), function (model) {
        //       let floor = model.setCoords([120.5664, 32.3854, index * 5]);
        //       floor.addEventListener(
        //         "SelectedChange",
        //         onFloorSelectedChange,
        //         false
        //       );
        //       floors.push(floor);
        //       tb.add(floor);
        //     });
        //   }
        // );

        // tb.loadObj(options, function (model) {
        //   const truck = model.setCoords([120.56642, 32.38535]);
        //  // truck.addEventListener("SelectedChange", onSelectedChange, false);
        //   tb.add(truck);
        // });
        function onFloorSelectedChange(e) {

         

          let selected = e.detail.selected;
          if (selected) {
            floors.forEach((fl, index) => {
              var c = tb.utils.projectToWorld([120.5664, 32.3854, index * 10]);
              new TWEEN.Tween(fl.position)
            .to(
              {
                z: c.z,
              },
              500
            )
            .onComplete(function () {
             
            })
            .start();
            });
          } else {
            floors.forEach((fl, index) => {
              var c = tb.utils.projectToWorld([120.5664, 32.3854, index * 5]);
              new TWEEN.Tween(fl.position)
            .to(
              {
                z: c.z,
              },
              500
            )
            .onComplete(function () {
             
            })
            .start();
            });
          }
        }

        function onSelectedChange(e) {
          let selected = e.detail.selected;
          if (selected) {
            if (floor) {
              tb.add(floor);
            }
            e.detail.children.forEach((ele) => {
              ele.children[0].material.opacity = 0.1;
            });
          } else {
            if (floor) {
              tb.remove(floor, false);
            }
            e.detail.children.forEach((ele) => {
              ele.children[0].material.opacity = 1;
            });
          }
        }

        function addTripLayer(routes) {
          const datas=[]
          routes.features.forEach((fea, index)  => {
            if(fea.type==='LineString'){
              datas.push({
            coordinates: fea.geometry.coordinates,
            timestamps: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120].map(
              (e) => e + index * 10
            ),
          })
            }
          });
   

        const tripLayer = new MapboxLayer({
          type: TripsLayer,
          id: "trips-layer1",
          datas,
          getPath: (d) => d.coordinates,
          getTimestamps: (d) => d.timestamps,
          getColor: [253, 128, 93],
          opacity: 0.8,
          widthMinPixels: 2,
          rounded: true,
          trailLength: 200,
        });

        map.addLayer(tripLayer);
        return tripLayer;
        }

        function addRing() {
          var ringmaterial = getRingMaterial(0);
          const ringgeometry = new THREE.RingBufferGeometry(
            0.001,
            10,
            20,
            5,
            0,
            Math.PI * 2
          );
          const ringmesh = new THREE.Mesh(ringgeometry, ringmaterial);

          tb.add(
            tb
              .Object3D({ obj: ringmesh, adjustment: { x: 0, y: 0, z: 0.5 } })
              .setCoords([120.55881500244139, 32.389655856727444])
          );

          return ringmesh;
        }

        function addBar(material) {
          const cubeGeo = new THREE.BoxBufferGeometry(0.05, 40, 0.05);
          cubeGeo.setAttribute(
            "color",
            new THREE.BufferAttribute(new Float32Array(24 * 3), 3)
          ); // setAttribute 以前是.addAttribute
          // 相当于在 shader中创建了 attribute vec4 position
          const colors1 = cubeGeo.attributes.color;
          for (let i = 0; i < 24; i += 2) {
            let r = Math.random() * 0.8,
              g = Math.random() * 0.7,
              b = Math.random() * 0.5;
            colors1.setXYZ(i, r, g, b);
            colors1.setXYZ(i + 1, r, g, b);
          }
          const k = 2;
          colors1.setXYZ(k * 4 + 0, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 1, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 2, 0.0, 1.0, 1.0);
          colors1.setXYZ(k * 4 + 3, 0.0, 1.0, 1.0);
          const cube = new THREE.Mesh(cubeGeo, material);

          cube.rotation.x = Math.PI / 2;
          tb.add(
            tb
              .Object3D({ obj: cube, adjustment: { x: 0, y: 0, z: 0.5 } })
              .setCoords([120.55881500244139, 32.389655856727444])
          );
        }

        function addSphere() {
          let spheregeo = new THREE.SphereGeometry(
            10,
            40,
            40,
            0,
            Math.PI * 2,
            0,
            Math.PI / 2
          );
          const mesh = new THREE.Mesh(spheregeo, getSphereMaterial());
          mesh.rotation.x = Math.PI / 2;
          tb.add(
            tb
              .Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 0.001 } })
              .setCoords([120.55812835693358, 32.39520021904035])
          );
        }

        function getWallGeometry(line, height) {

          let bs = line[0];
          let points = line.map(item => {
            let x = (item[0] - bs[0])*3100 ;
            let y = (item[1] - bs[1])*3100 ;
            return new THREE.Vector2(x, y);
          });

          // var straightProject = tb.utils.lnglatsToWorld(line);
          // var points = tb.utils.normalizeVertices(straightProject);
          // var flattenedArray = tb.utils.flattenVectors(normalized.vertices);
          let positions = [];
          let uvs = [];
          for (
            let i = 0, j = positions.length, t = uvs.length;
            i < points.length - 1;
            i++
          ) {
            let vUvyMax = 1;
            let left = points[i];
            let right = points[i + 1];
            positions[j++] = left.x;
            positions[j++] = left.y;
            positions[j++] = 0;
            uvs[t++] = 0;
            uvs[t++] = 0;

            positions[j++] = right.x;
            positions[j++] = right.y;
            positions[j++] = 0;
            uvs[t++] = 1;
            uvs[t++] = 0;

            positions[j++] = left.x;
            positions[j++] = left.y;
            positions[j++] = height;
            uvs[t++] = 0;
            uvs[t++] = vUvyMax;

            positions[j++] = left.x;
            positions[j++] = left.y;
            positions[j++] = height;
            uvs[t++] = 0;
            uvs[t++] = vUvyMax;

            positions[j++] = right.x;
            positions[j++] = right.y;
            positions[j++] = 0;
            uvs[t++] = 1;
            uvs[t++] = 0;

            positions[j++] = right.x;
            positions[j++] = right.y;
            positions[j++] = height;
            uvs[t++] = 1;
            uvs[t++] = vUvyMax;
          }
          let geometry = new THREE.BufferGeometry();
          geometry.addAttribute(
            "position",
            new THREE.BufferAttribute(new Float32Array(positions), 3)
          );
          geometry.addAttribute(
            "uv",
            new THREE.BufferAttribute(new Float32Array(uvs), 2)
          );
          return geometry;
        }
        function addWall(params) {
          const geometry = getWallGeometry(
            [
           
            [
              120.56302607059479,
              32.390421397594814
            ],
            [
              120.56363761425018,
              32.38780766031788
            ],
            [
              120.56435108184814,
              32.38795261826575
            ],
            [
              120.56506454944609,
              32.38821535395333
            ],
            [
              120.56580483913422,
              32.38878159206095
            ],
            [
              120.56656122207643,
              32.38931611757739
            ],
            [
              120.56727468967436,
              32.390086191149685
            ],
            [
              120.56695282459258,
              32.39065241752877
            ],
            [
              120.56655585765837,
              32.390521053325074
            ],
            [
              120.56613206863403,
              32.39038515912019
            ],
            [
              120.56581020355225,
              32.390992151652284
            ],
            [
              120.5651342868805,
              32.39077019216963
            ],
            [
              120.56458711624147,
              32.39072036445571
            ],
            [
              120.56302607059479,
              32.390421397594814
            ]
            ],
            2
          );
          const mesh = new THREE.Mesh(geometry, getWallMaterial());
          mesh.rotation.z = Math.PI;
          tb.add(
            tb
              .Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 0.01 } })
              .setCoords([120.56302607059479,
              32.390421397594814])
          );
          return mesh;
        }

        function addCone(point,color) {
          let geometry = new THREE.CylinderBufferGeometry(
            0,
            6.4,
            11,
            4,
            1,
            false,
            0,
            6.3
          );
          geometry.scale(0.1, 0.1, 0.1);
          // geometry.computeBoundingSphere();
          const mesh = new THREE.Mesh(geometry, getConeMaterial(color));
          mesh.rotation.x = -Math.PI / 2;
          tb.add(
            tb
              .Object3D({ obj: mesh, adjustment: { x: 0, y: 0, z: 2 } })
              .setCoords(point)
          );

          return mesh;
        }

        let texture = new THREE.TextureLoader().load("images/red_line.png");
        let texture2 = new THREE.TextureLoader().load("images/green_line.png");
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture2.wrapS = THREE.RepeatWrapping;
        texture2.wrapT = THREE.RepeatWrapping;

        function addLine() {
          var arcSegments = 25;
          var linemeshs = [];
          var origns = [
            [120.51298141479494, 32.39489220784177],
            [120.57529449462889, 32.41692141725631],
            [120.57580947875977, 32.383295727889326],
          ];

          var destination = [120.55812835693358, 32.39520021904035];

          var maxElevation =
            Math.pow(Math.abs(destination[0] * destination[1]), 0.5) * 20;

          var increments = origns.map((orign) =>
            turf.greatCircle(orign, destination, { npoints: 25 })
          );

          increments.forEach((ment, index) => {
            var line = new Array();
            for (var l = 0; l < arcSegments; l++) {
              var waypoint = ment.geometry.coordinates[l];

              var waypointElevation =
                Math.sin((Math.PI * l) / arcSegments) * maxElevation;

              waypoint.push(waypointElevation);
              line.push(waypoint);
            }
            var straightProject = tb.utils.lnglatsToWorld(line);
            var normalized = tb.utils.normalizeVertices(straightProject);
            var flattenedArray = tb.utils.flattenVectors(normalized.vertices);

            const meshLine = new MeshLine();
            meshLine.setGeometry(normalized);

            let material = new MeshLineMaterial({
              map: index % 2 == 0 ? texture : texture2,
              useMap: true,
              lineWidth: 20,
              resolution: resolution,
              dashArray: 0.9, // 破折号之间的长度和间距。(0 -无破折号)
              dashRatio: 0.3, // 定义可见和不可见之间的比率(0 -更可见，1 -更不可见)。
              dashOffset: 0,
              transparent: true,
              sizeAttenuation: 0.5, //使线宽不变，不管距离(1个单位是屏幕上的1px)(0 -衰减，1 -不衰减)
              side: THREE.DoubleSide,
              depthTest: false,
              blending: THREE.AdditiveBlending,
              near: tb.camera.near,
              far: tb.camera.far,
            });

            var tmp = new THREE.Mesh(meshLine.geometry, material);
            tb.add(
              tb
                .Object3D({ obj: tmp, adjustment: { x: 0, y: 0, z: 0.5 } })
                .setCoords([line[12][0], line[12][1]])
            );

            linemeshs.push(tmp);
          });

          return linemeshs;
        }

        function addCircle(point) {
        var texture = new THREE.TextureLoader().load("images/circular.png");
        var material = new THREE.MeshLambertMaterial({
          map: texture,
          side: THREE.FrontSide,
          transparent: true,
        });
        function getRingeGeometry(width = 7, height = 7) {
        return new THREE.PlaneGeometry(width, height);
      }

        var ringeGeom = getRingeGeometry();

        cube = new THREE.Mesh(ringeGeom, material);
        cube3d = tb
          .Object3D({ obj: cube, adjustment: { x: 0, y: 0, z: 0.1 } })
          .setCoords(point);

        tb.add(cube3d);
        return cube;
      }

        function addRoads() {
          var arcSegments = 25;
          var linemeshs = [];
          var roads = [
            [
            [
            120.5615186691284,
            32.38396618993527
          ],
          [
            120.56115388870238,
            32.385198377476435
          ],
          [
            120.56441545486449,
            32.386629868367656
          ],
          [
            120.56355714797974,
            32.38797073799289
          ],
          [
            120.56312799453734,
            32.389655856727444
          ],
          [
            120.56392192840576,
            32.389764572985584
          ]
            ],
            [
            [
            120.55293560028075,
            32.38845996925133
          ],
          [
            120.55224895477294,
            32.39039874854987
          ],
          [
            120.56177616119385,
            32.39313471207973
          ],
          [
            120.56229114532472,
            32.39291728754617
          ],
          [
            120.56313872337343,
            32.38959243884977
          ],
          [
            120.56387901306152,
            32.38973739393332
          ]
            ],
          ];

          roads.forEach((line, index) => {
            var straightProject = tb.utils.lnglatsToWorld(line);
            var normalized = tb.utils.normalizeVertices(straightProject);
            var flattenedArray = tb.utils.flattenVectors(normalized.vertices);

            const meshLine = new MeshLine();
            meshLine.setGeometry(normalized);

            let material = new MeshLineMaterial({
              map: texture,
              useMap: true,
              lineWidth: 40,
              resolution: resolution,
              dashArray: 0.9, // 破折号之间的长度和间距。(0 -无破折号)
              dashRatio: 0.3, // 定义可见和不可见之间的比率(0 -更可见，1 -更不可见)。
              dashOffset: 0,
              transparent: true,
              sizeAttenuation: 0.5, //使线宽不变，不管距离(1个单位是屏幕上的1px)(0 -衰减，1 -不衰减)
              side: THREE.DoubleSide,
              depthTest: false,
              blending: THREE.AdditiveBlending,
              near: tb.camera.near,
              far: tb.camera.far,
            });

            var tmp = new THREE.Mesh(meshLine.geometry, material);
            var features = turf.featureCollection(line.map(e=>{return turf.point(e)}));

            var center=turf.center(features);
            console.log(center)
            tb.add(
              tb
                .Object3D({ obj: tmp, adjustment: { x: 0, y: 0, z: 0.5 } })
                .setCoords(center.geometry.coordinates)
            );

            linemeshs.push(tmp);
          });

          return linemeshs;
        }
         //var roadmeshs = addRoads();
       
         //add3DLabels();
        // var linemeshs = addLine();
        // var ringmesh = addRing();
        //  var wallmesh = addWall();
        //  var circlemesh=addCircle([ 120.55259227752686,32.388151935064236]);
        // var conemesh = addCone([ 120.56514501571654,32.3897192745606],"#eee");
        // var conemesh2 = addCone([  120.56062817573546,32.3841564552852]);
        // var conemesh3 = addCone([  120.55259227752686,32.388151935064236]);
        var tripLayer=addTripLayer(routes);
        // var shaderBarmaterial = getShaderBarMaterial();
        // addBar(shaderBarmaterial);
        // var ShaderBar = shaderBarmaterial.ShaderBar;
        // addSphere();

        var animate = function () {

          var loopLength = 300; // unit corresponds to the timestamp in source data
          var animationSpeed = 30; // unit time per second
          var timestamp = Date.now() / 1000;
          var loopTime = loopLength / animationSpeed;
          let curtime = ((timestamp % loopTime) / loopTime) * loopLength;
          if (tripLayer.setProps) {
            try {
              tripLayer.setProps({ currentTime: curtime });
            } catch (error) {}
          }


          // ringmesh.material.uniforms.time.value += 0.002;
          //  wallmesh.material.uniforms.time.value += 0.008;
          //  conemesh.material.uniforms.time.value += 0.05;
          //  conemesh.rotation.y += 0.02;
          //  conemesh3.material.uniforms.time.value += 0.05;
          //  conemesh3.rotation.y += 0.02;
          //  conemesh2.material.uniforms.time.value += 0.05;
          //  conemesh2.rotation.y += 0.02;
          //  circlemesh.rotation.z += 0.02;
          // linemeshs.forEach((linemesh) => {
          //   linemesh.material.uniforms.dashOffset.value -= 0.01;
          // });

          // roadmeshs.forEach((linemesh) => {
          //   linemesh.material.uniforms.dashOffset.value -= 0.01;
          // });
          // 
          // ShaderBar.uniforms.boxH.value = ShaderBar.uniforms.boxH.value + 0.5;
          // if (ShaderBar.uniforms.boxH.value > 40) {
          //   ShaderBar.uniforms.boxH.value = -10.0;
          // }

          requestAnimationFrame(animate);
          map.triggerRepaint();
        };

        animate();
      }
    </script>
  </body>
</html>
